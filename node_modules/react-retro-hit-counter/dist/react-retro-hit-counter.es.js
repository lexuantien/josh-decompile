import React, {
    PureComponent
} from 'react';

var padStart = function padStart(str, targetLength, padString) {
    var useNative = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    if (useNative && typeof String.prototype.padStart === 'function') {
        return str.padStart(targetLength, padString);
    }

    if (str.length >= targetLength) {
        return str;
    }

    var numToPad = targetLength - str.length;

    var padding = '';
    for (var i = 0; i < numToPad; i++) {
        padding = '' + padString + padding;
    }

    return '' + padding + str;
};

var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
};









var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target;
};



var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Segment = function Segment(_ref) {
    var segmentId = _ref.segmentId,
        thickness = _ref.thickness,
        spacing = _ref.spacing,
        activeColor = _ref.activeColor,
        inactiveColor = _ref.inactiveColor,
        parentWidth = _ref.parentWidth,
        parentHeight = _ref.parentHeight,
        isActive = _ref.isActive;

    var halfThickness = thickness / 2;
    var segmentLength = parentWidth - thickness;

    // TODO: Should this be configurable?
    var animationDuration = 250;

    // The segments are based on seven-segment displays.
    // IDs are calculated going clockwise from the top:
    //
    //     A
    //  F     B
    //     G
    //  E     C
    //     D
    //
    // More info: https://en.wikipedia.org/wiki/Seven-segment_display
    var segments = {
        a: {
            top: 0,
            left: halfThickness
        },
        b: {
            top: halfThickness,
            left: segmentLength + thickness,
            transform: 'rotate(90deg)',
            transformOrigin: 'top left'
        },
        c: {
            top: halfThickness + segmentLength,
            left: segmentLength + thickness,
            transform: 'rotate(90deg)',
            transformOrigin: 'top left'
        },
        d: {
            bottom: 0,
            left: halfThickness
        },
        e: {
            top: halfThickness + segmentLength,
            left: thickness,
            transform: 'rotate(90deg)',
            transformOrigin: 'top left'
        },
        f: {
            top: halfThickness,
            left: thickness,
            transform: 'rotate(90deg)',
            transformOrigin: 'top left'
        },
        g: {
            top: segmentLength,
            left: halfThickness
        }
    };

    return React.createElement(
        'div', {
            style: _extends({
                position: 'absolute'
            }, segments[segmentId])
        },
        React.createElement(
            'svg', {
                width: segmentLength,
                height: thickness,
                style: {
                    display: 'block'
                }
            }, [inactiveColor, activeColor].map(function(color, index) {
                return React.createElement('path', {
                    key: index,
                    fill: color,
                    style: {
                        opacity: color === activeColor ? isActive ? 1 : 0 : 1,
                        transition: 'opacity ' + animationDuration + 'ms'
                    },
                    d: '\n              M ' + spacing + ' ' + halfThickness + '\n              L ' + (halfThickness + spacing) + ' 0\n              L ' + (segmentLength - halfThickness - spacing) + ' 0\n              L ' + (segmentLength - spacing) + ' ' + halfThickness + '\n              L ' + (segmentLength - halfThickness - spacing) + ' ' + thickness + '\n              L ' + (halfThickness + spacing) + ' ' + thickness + '\n            '
                });
            })
        )
    );
};

var _segmentsByValue;

var segmentsByValue = (_segmentsByValue = {}, _segmentsByValue[0] = ['a', 'b', 'c', 'd', 'e', 'f'], _segmentsByValue[1] = ['b', 'c'], _segmentsByValue[2] = ['a', 'b', 'g', 'e', 'd'], _segmentsByValue[3] = ['a', 'b', 'g', 'c', 'd'], _segmentsByValue[4] = ['f', 'g', 'b', 'c'], _segmentsByValue[5] = ['a', 'f', 'g', 'c', 'd'], _segmentsByValue[6] = ['a', 'f', 'g', 'c', 'd', 'e'], _segmentsByValue[7] = ['a', 'b', 'c'], _segmentsByValue[8] = ['a', 'b', 'c', 'd', 'e', 'f', 'g'], _segmentsByValue[9] = ['a', 'b', 'c', 'd', 'f', 'g'], _segmentsByValue);

var isSegmentActive = function isSegmentActive(segmentId, value) {
    return segmentsByValue[value].indexOf(segmentId) !== -1;
};

var segments = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

var Digit = function Digit(_ref) {
    var value = _ref.value,
        width = _ref.width,
        height = _ref.height,
        segmentThickness = _ref.segmentThickness,
        segmentSpacing = _ref.segmentSpacing,
        segmentActiveColor = _ref.segmentActiveColor,
        segmentInactiveColor = _ref.segmentInactiveColor;
    return React.createElement(
        'div', {
            style: styles.wrapper(width, height)
        },
        segments.map(function(segmentId) {
            return React.createElement(Segment, {
                key: segmentId,
                segmentId: segmentId,
                thickness: segmentThickness,
                spacing: segmentSpacing,
                activeColor: segmentActiveColor,
                inactiveColor: segmentInactiveColor,
                parentWidth: width,
                parentHeight: height,
                isActive: isSegmentActive(segmentId, value)
            });
        })
    );
};

var styles = {
    wrapper: function wrapper(width, height) {
        return {
            position: 'relative',
            width: width,
            height: height
        };
    }
};

// Figure out our backing scale.
// This ensures canvas looks crisp on retina displays, where there are
// in fact 4 on-screen pixels for every 1 calculated pixel.
function scaleCanvas(canvas, ctx, width, height) {
    // If we're rendering on the server, do nothing.
    if (typeof window === 'undefined') {
        return;
    }

    width = typeof width === 'number' ? width : canvas.width;
    height = typeof height === 'number' ? height : canvas.height;

    var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

    // $FlowFixMe - apparently backingStoreRatio can contain non-numbers?
    var ratio = (window.devicePixelRatio || 1) / backingStoreRatio;

    if (ratio > 1) {
        /* eslint-disable no-param-reassign */
        canvas.style.height = height + 'px';
        canvas.style.width = width + 'px';
        canvas.width = width * ratio;
        canvas.height = height * ratio;
        /* eslint-enable */

        ctx.scale(ratio, ratio);
    }
}

/**
 * Add a 90s Retro Border to any children!
 * Uses Canvas, since not all border sides are the same. As such, it may look
 * more complicated than you expected, but this is necessary to get the right
 * aesthetic.
 */
var GRADIENTS = {
    outer: [{
        stop: 0,
        color: '#394e6f'
    }, {
        stop: 0.3,
        color: '#7695cc'
    }, {
        stop: 0.6,
        color: '#b5c8f0'
    }, {
        stop: 0.9,
        color: '#b5c4e1'
    }, {
        stop: 1,
        color: '#98a9cb'
    }],
    inner: [{
        stop: 0,
        color: '#394e6f'
    }, {
        stop: 0.15,
        color: '#546f8c'
    }, {
        stop: 0.5,
        color: '#b5c8f0'
    }, {
        stop: 0.8,
        color: '#c5d8f9'
    }, {
        stop: 1,
        color: '#7991bc'
    }]
};

var BORDERS = [{
    // top
    gradientStops: GRADIENTS.outer,
    getGradientCoords: function getGradientCoords(_ref) {
        var width = _ref.width,
            height = _ref.height,
            thickness = _ref.thickness;
        return [0, thickness, 0, 0];
    },
    getPoints: function getPoints(_ref2) {
        var width = _ref2.width,
            height = _ref2.height,
            thickness = _ref2.thickness;
        return [
            [0, 0],
            [thickness, thickness],
            [width - thickness, thickness],
            [width, 0]
        ];
    }
}, {
    // left
    gradientStops: GRADIENTS.outer,
    getGradientCoords: function getGradientCoords(_ref3) {
        var width = _ref3.width,
            height = _ref3.height,
            thickness = _ref3.thickness;
        return [thickness, 0, 0, 0];
    },
    getPoints: function getPoints(_ref4) {
        var width = _ref4.width,
            height = _ref4.height,
            thickness = _ref4.thickness;
        return [
            [0, 0],
            [thickness, thickness],
            [thickness, height - thickness],
            [0, height]
        ];
    }
}, {
    // right
    gradientStops: GRADIENTS.inner,
    getGradientCoords: function getGradientCoords(_ref5) {
        var width = _ref5.width,
            height = _ref5.height,
            thickness = _ref5.thickness;
        return [width, 0, width - thickness, 0];
    },
    getPoints: function getPoints(_ref6) {
        var width = _ref6.width,
            height = _ref6.height,
            thickness = _ref6.thickness;
        return [
            [width, 0],
            [width - thickness, thickness],
            [width - thickness, height - thickness],
            [width, height]
        ];
    }
}, {
    // bottom
    gradientStops: GRADIENTS.inner,
    getGradientCoords: function getGradientCoords(_ref7) {
        var width = _ref7.width,
            height = _ref7.height,
            thickness = _ref7.thickness;
        return [0, height, 0, height - thickness];
    },
    getPoints: function getPoints(_ref8) {
        var width = _ref8.width,
            height = _ref8.height,
            thickness = _ref8.thickness;
        return [
            [0, height],
            [thickness, height - thickness],
            [width - thickness, height - thickness],
            [width, height]
        ];
    }
}];

var RetroBorder = function(_PureComponent) {
    inherits(RetroBorder, _PureComponent);

    function RetroBorder() {
        var _temp, _this, _ret;

        classCallCheck(this, RetroBorder);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.handleRef = function(canvas) {
            if (!canvas) {
                return;
            }

            _this.canvas = canvas;
            _this.ctx = canvas.getContext('2d');

            scaleCanvas(_this.canvas, _this.ctx);
        }, _this.draw = function() {
            var _this$props = _this.props,
                width = _this$props.width,
                height = _this$props.height,
                thickness = _this$props.thickness;


            if (typeof width !== 'number' || typeof height !== 'number') {
                return;
            }

            BORDERS.forEach(function(_ref9) {
                var _this$ctx, _this$ctx2;

                var gradientStops = _ref9.gradientStops,
                    getGradientCoords = _ref9.getGradientCoords,
                    getPoints = _ref9.getPoints;

                var data = {
                    width: width,
                    height: height,
                    thickness: thickness
                };

                var gradient = (_this$ctx = _this.ctx).createLinearGradient.apply(_this$ctx, getGradientCoords(data));

                gradientStops.forEach(function(_ref10) {
                    var stop = _ref10.stop,
                        color = _ref10.color;
                    return gradient.addColorStop(stop, color);
                });

                var _getPoints = getPoints(data),
                    startingPoint = _getPoints[0],
                    connectedPoints = _getPoints.slice(1);

                _this.ctx.beginPath();
                (_this$ctx2 = _this.ctx).moveTo.apply(_this$ctx2, startingPoint);

                connectedPoints.forEach(function(point) {
                    var _this$ctx3;

                    return (_this$ctx3 = _this.ctx).lineTo.apply(_this$ctx3, point);
                });

                _this.ctx.closePath();

                _this.ctx.fillStyle = gradient;
                _this.ctx.fill();
            });
        }, _temp), possibleConstructorReturn(_this, _ret);
    }

    RetroBorder.prototype.componentDidMount = function componentDidMount() {
        this.draw();
    };

    RetroBorder.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (this.props.width !== prevProps.width || this.props.height !== prevProps.height) {
            scaleCanvas(this.canvas, this.ctx, this.props.width, this.props.height);
        }

        this.draw();
    };

    RetroBorder.prototype.render = function render() {
        var _props = this.props,
            width = _props.width,
            height = _props.height,
            thickness = _props.thickness,
            children = _props.children;


        return React.createElement(
            'div', {
                style: styles$1.wrapper(this.props)
            },
            React.createElement(
                'div', {
                    style: styles$1.childWrapper()
                },
                children
            ),
            React.createElement('canvas', {
                width: width,
                height: height,
                style: styles$1.canvas({
                    width: width,
                    height: height
                }),
                ref: this.handleRef
            })
        );
    };

    return RetroBorder;
}(PureComponent);

RetroBorder.defaultProps = {
    thickness: 7
};


var styles$1 = {
    wrapper: function wrapper(_ref11) {
        var thickness = _ref11.thickness;
        return {
            display: 'inline-block',
            position: 'relative',
            padding: thickness
        };
    },

    childWrapper: function childWrapper() {
        return {
            position: 'relative',
            zIndex: 3
        };
    },

    canvas: function canvas(_ref12) {
        var width = _ref12.width,
            height = _ref12.height;
        return {
            position: 'absolute',
            zIndex: 1,
            top: 0,
            left: 0,
            right: 0,
            bottom: 0
        };
    }
};

var RetroHitCounter = function(_PureComponent) {
    inherits(RetroHitCounter, _PureComponent);

    function RetroHitCounter() {
        classCallCheck(this, RetroHitCounter);
        return possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
    }

    RetroHitCounter.prototype.render = function render() {
        var _props = this.props,
            hits = _props.hits,
            minLength = _props.minLength,
            size = _props.size,
            backgroundColor = _props.backgroundColor,
            padding = _props.padding,
            segmentThickness = _props.segmentThickness,
            segmentSpacing = _props.segmentSpacing,
            segmentActiveColor = _props.segmentActiveColor,
            segmentInactiveColor = _props.segmentInactiveColor,
            digitSpacing = _props.digitSpacing,
            withBorder = _props.withBorder,
            borderThickness = _props.borderThickness,
            withGlow = _props.withGlow,
            glowSize = _props.glowSize,
            glowStrength = _props.glowStrength;

        // NOTE: Each segment in each digit is exactly the same size. This means a
        // very specific aspect ratio is necessary.
        //
        // The "base" aspect ratio is 0.5: there are 2 vertical segments and 1
        // horizontal one, so the width should be half of the height.
        // This gets messed up with segment spacing: both the horizontal and
        // vertical directions have 1 `segmentThickness` worth of additional space.
        // The vertical ('side') segments don't quite reach the top/bottom, and the
        // horizontal ones don't quite reach the sides.
        //
        // To fix this, we need to multiply the base aspect ratio, 0.5, by the ratio
        // between height and segment thickness. The thicker the segment is, the
        // further from that 0.5 default we get.

        var aspectRatio = 0.5 * (1 + segmentThickness / size);

        var characterHeight = size;
        var characterWidth = characterHeight * aspectRatio;

        var paddedValue = padStart(hits.toString(), minLength, '0');
        var individualDigits = paddedValue.split('');

        var totalWidth =
            // Total width is each number's width,
            characterWidth * individualDigits.length +
            // plus spacing between them (eg 3x the spacing for 4 digits)
            digitSpacing * (individualDigits.length - 1);

        var shouldShowGlow = withGlow && glowStrength > 0;

        var counter = React.createElement(
            'div', {
                style: styles$2.wrapper()
            },
            React.createElement(
                'div', {
                    style: styles$2.counter(backgroundColor, padding, totalWidth)
                },
                individualDigits.map(function(digit, index) {
                    return React.createElement(Digit, {
                        key: index,
                        value: Number(digit),
                        width: characterWidth,
                        height: characterHeight,
                        segmentThickness: segmentThickness,
                        segmentSpacing: segmentSpacing,
                        segmentActiveColor: segmentActiveColor,
                        segmentInactiveColor: segmentInactiveColor
                    });
                })
            ),
            shouldShowGlow && React.createElement('div', {
                style: styles$2.glow({
                    strength: glowStrength,
                    color: segmentActiveColor,
                    size: glowSize
                })
            })
        );

        if (!withBorder) {
            return counter;
        }

        return React.createElement(
            RetroBorder, {
                width: totalWidth + padding * 2 + borderThickness * 2,
                height: characterHeight + padding * 2 + borderThickness * 2,
                thickness: borderThickness,
                glowColor: segmentActiveColor,
                glowStrength: glowStrength
            },
            counter
        );
    };

    return RetroHitCounter;
}(PureComponent);

RetroHitCounter.defaultProps = {
    minLength: 4,
    size: 40,
    padding: 4,
    digitSpacing: 3,
    segmentThickness: 4,
    segmentSpacing: 0.5,
    segmentActiveColor: '#76FF03',
    segmentInactiveColor: '#315324',
    backgroundColor: '#222222',
    withBorder: true,
    borderThickness: 7,
    withGlow: false,
    glowSize: 2,
    glowStrength: 0.4
};


var styles$2 = {
    wrapper: function wrapper() {
        return {
            position: 'relative',
            display: 'inline-block'
        };
    },
    counter: function counter(backgroundColor, padding, width) {
        return {
            position: 'relative',
            zIndex: 2,
            display: 'flex',
            justifyContent: 'space-between',
            width: width,
            backgroundColor: backgroundColor,
            padding: padding,
            boxSizing: 'content-box'
        };
    },

    withBorderWrapper: function withBorderWrapper(borderWidth) {
        return {
            position: 'relative',
            display: 'inline-block',
            padding: borderWidth,
            background: '#CCC'
        };
    },

    counterWrapper: function counterWrapper() {
        return {
            position: 'relative',
            zIndex: 1,
            boxSizing: 'content-box'
        };
    },

    glow: function glow(_ref) {
        var strength = _ref.strength,
            color = _ref.color,
            size = _ref.size;
        return {
            position: 'absolute',
            zIndex: 1,
            top: -size,
            left: -size,
            right: -size,
            bottom: -size,
            background: color,
            filter: 'blur(' + size + 'px)',
            opacity: strength
        };
    }
};

export default RetroHitCounter;
export {
    RetroBorder
};